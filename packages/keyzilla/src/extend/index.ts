#!/usr/bin/env node

import { ApiKey } from "../types/apikeys";
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import { v4 as uuidv4 } from 'uuid'; // Make sure to install and import uuid
import { z } from "zod";
/** 
 * This function get the env file `env.ts` wich is generated by `keyzilla` and format it to a more readable format 
 * so the output can be used to extend the env file in your project 
 * @example 
 * 
 * 
 * import { createEnv } from "@t3-oss/env-nextjs";
 * import { z } from "zod";
 * 
 * export k = createEnv({
 * client: {
 *   "NEXT_PUBLIC_API_KEY": z.string().min(1),
 * },
 * server: {
 *   "API_KEY": z.string().min(1),
 * },
 * runtimeEnv: {
 *   "NEXT_PUBLIC_API_KEY": "something",
 *   "API_KEY": "something"
 * }
 * })
 * 
 * this is the output
 *   ======> 
 * 
 * {
 *   client: [
 *     {
 *       key: "NEXT_PUBLIC_API_KEY",
 *       value: "something",
 *       isServer: false
 *     }
 *     
 * ],
 * server: [
 *   {
 *     key: "API_KEY",
 *     value: "something",
 *     isServer: true
 *   }
 * ],
 * 
 * wich remaps again as auto-complete in your IDE 
 */




// this is only a helper function to format the env file to a more readable format
// ? whay do we need to format the env file to a more readable format ?
// ? to give you full type safety and auto-complete in your IDE 
// if you named an env variable NEXT_PUBLIC_API_KEY, it will be mapped to NEXT_PUBLIC_API_KEY
// example: 
// NEXT_PUBLIC_API_KEY=something
// you extend it to NEXT_PUBLIC_API_KEYs=something
// in the en
function formatEnvtoJson(): { client: ApiKey[], server: ApiKey[] } {
    const projectRoot = process.cwd()
    const keyzillaDistPath = path.join(projectRoot, 'dist')
    const envPath = path.join(keyzillaDistPath, "env.ts")
    
    // Read the file content
    const envContent = fs.readFileSync(envPath, "utf-8")
    

    // Extract client, server, and runtimeEnv configurations
    const clientMatch = envContent.match(/client:\s*({[\s\S]*?}),/);
    const serverMatch = envContent.match(/server:\s*({[\s\S]*?}),/);
    const runtimeEnvMatch = envContent.match(/runtimeEnv:\s*({[\s\S]*?}),/);

    if (!clientMatch || !serverMatch || !runtimeEnvMatch) {
        throw new Error("Unable to extract configuration from env.ts");
    }

    // Extract keys using regex
    function extractKeys(str: string): string[] {
        const keyRegex = /"([^"]+)":/g;
        const keys = [];
        let match;
        while ((match = keyRegex.exec(str)) !== null) {
            keys.push(match[1]);
        }
        return keys;
    }

    const clientKeys = extractKeys(clientMatch[1]);
    const serverKeys = extractKeys(serverMatch[1]);

    // Parse runtimeEnv
    const runtimeEnvStr = runtimeEnvMatch[1].replace(/'/g, '"');
    const runtimeEnv = JSON.parse(runtimeEnvStr);

    const projectId = uuidv4();

    const client: ApiKey[] = clientKeys.map(key => ({
        _id: uuidv4(),
        name: key,
        apiKey: runtimeEnv[key],
        isServer: false,
        projectId
    }));

    const server: ApiKey[] = serverKeys.map(key => ({
        _id: uuidv4(),
        name: key,
        apiKey: runtimeEnv[key],
        isServer: true,
        projectId
    }));

    return { client, server };
}

// New type for additional keys
type AdditionalKeys = Record<string, string>;

// New type for the extend function return value
type ExtendedEnv = {
    [K in ApiKey['name']]: string;
};

// Updated extend function
type EnvConfig = {
  client?: Record<string, string>;
  server?: Record<string, string>;
  runtimeEnv?: Record<string, string>;
  isServer?: boolean;
};

export function extend(userConfig: EnvConfig = {}): string {
    const { client: existingClient, server: existingServer } = formatEnvtoJson();
    
    const clientKeys = {
        ...Object.fromEntries(existingClient.map(k => [k.name, k.apiKey, ])),
        ...userConfig.client
    };
    const serverKeys = {
        ...Object.fromEntries(existingServer.map(k => [k.name, k.apiKey])),
        ...userConfig.server
    };
    const runtimeEnvKeys = {
        ...Object.fromEntries([...existingClient, ...existingServer].map(k => [k.name, k.apiKey])),
        ...userConfig.runtimeEnv
    };

    const clientObj = Object.keys(clientKeys).reduce((acc, key) => {
        acc[key] = 'z.string().min(1)';
        return acc;
    }, {} as Record<string, string>);

    const serverObj = Object.keys(serverKeys).reduce((acc, key) => {
        acc[key] = 'z.string().min(1)';
        return acc;
    }, {} as Record<string, string>);

    const prodEnvObj = Object.keys(runtimeEnvKeys).reduce((acc, key) => {
        const isServer = existingServer.some(k => k.name === key);
        acc[key] = `process.env["${key}"], ${isServer ? "// server" : "// client"}`;
        return acc;
    }, {} as Record<string, string>);

    const output = `
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

const env = createEnv({
  client: ${JSON.stringify(clientObj, null, 2)},
  server: ${JSON.stringify(serverObj, null, 2)},
  runtimeEnv: ${JSON.stringify(runtimeEnvKeys, null, 2)},
});

const isProd = process.env.NODE_ENV === 'production';

const prodEnv = ${JSON.stringify(prodEnvObj, null, 2).replace(/"/g, '')};

export const k = isProd ? prodEnv : env;
`;

    return output;
}

let env
 
env = process.env.NODE_ENV = "production"


// Example usage
const userConfig: EnvConfig = {
    client: {
        NEXT_PUBLIC_NEW_CLIENT_KEY: "new_client_value"
    },
    server: {
        NEW_SERVER_KEY: "new_server_value"
    },
    runtimeEnv: env !== "production" ? {
        NEXT_PUBLIC_OVERRIDE_KEY: "override_value",
        NEW_RUNTIME_KEY: "new_runtime_value" 
    } : {
        NEXT_PUBLIC_OVERRIDE_KEY: "override_value",
        NEW_RUNTIME_KEY: "new_runtime_value" 
    }
};

console.log(extend(userConfig));







